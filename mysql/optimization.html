<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.27">
    <title>MySQL 优化 | NOTES</title><meta name="description" content="Just playing around">
    <link rel="modulepreload" href="/assets/app.39480b94.js"><link rel="modulepreload" href="/assets/optimization.html.153e412a.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/optimization.html.cfe8bd95.js">
    <link rel="stylesheet" href="/assets/style.4634000d.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">NOTES</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">MySQL 优化</p><ul class=""><li><!--[--><a aria-current="page" href="/mysql/optimization.html#表优化" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="表优化"><!--[--><!--]--> 表优化 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/mysql/optimization.html#索引优化" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="索引优化"><!--[--><!--]--> 索引优化 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/mysql/optimization.html#聚簇索引" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="聚簇索引"><!--[--><!--]--> 聚簇索引 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/mysql/optimization.html#索引覆盖" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="索引覆盖"><!--[--><!--]--> 索引覆盖 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/mysql/optimization.html#联合索引" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="联合索引"><!--[--><!--]--> 联合索引 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/mysql/optimization.html#排序优化" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="排序优化"><!--[--><!--]--> 排序优化 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/mysql/optimization.html#sql-优化" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="SQL 优化"><!--[--><!--]--> SQL 优化 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/mysql/optimization.html#复杂语句拆分" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="复杂语句拆分"><!--[--><!--]--> 复杂语句拆分 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/mysql/optimization.html#in-型子查询陷阱" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="in 型子查询陷阱"><!--[--><!--]--> in 型子查询陷阱 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/mysql/optimization.html#from-型子查询慎用" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="from 型子查询慎用"><!--[--><!--]--> from 型子查询慎用 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/mysql/optimization.html#count-排序优化" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="count(*) 排序优化"><!--[--><!--]--> count(*) 排序优化 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/mysql/optimization.html#limit-分页优化" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="limit 分页优化"><!--[--><!--]--> limit 分页优化 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="mysql-优化" tabindex="-1"><a class="header-anchor" href="#mysql-优化" aria-hidden="true">#</a> MySQL 优化</h1><h2 id="表优化" tabindex="-1"><a class="header-anchor" href="#表优化" aria-hidden="true">#</a> 表优化</h2><ol><li>定长字段与变长字段分离；</li><li>常用字段与不常用字段分离；</li><li>添加冗余字段，反范式化；</li></ol><p>字段类型选择：整形 &gt; date/time &gt; enum/char &gt; varchar &gt; blob/text</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>date/time：需要考虑时区
enum：底层存储为整形，需要完成字符串与整形之间的转换
char：需要考虑字符集与校对集
varchar：不定长，需要考虑字符集与校对集，慢
blob/text：无法使用内存临时表，排序等操作只能在硬盘完成
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="索引优化" tabindex="-1"><a class="header-anchor" href="#索引优化" aria-hidden="true">#</a> 索引优化</h2><ul><li>B-Tree 索引</li><li>Hash 索引（Memory 引擎） <ol><li>随机 IO</li><li>不支持范围查询</li><li>不支持前缀查询</li><li>无法优化排序</li><li>必须回行</li></ol></li></ul><h3 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引" aria-hidden="true">#</a> 聚簇索引</h3><p>MyISAM 和 InnoDB 引擎都属于 B-Tree 索引，但实现细节又有所不同。InnoDB 是聚簇索引，MyISAM 是非聚簇索引。</p><p>在 MyISAM 中，每个索引指向的是行在磁盘上的位置，最终取出数据需要回行。而 InnoDB 引擎主键索引（若没有 Primary Key，则使用 Unique Key，再没有系统会内部生成一个 rowid 做主键）则和数据分布在同一叶子结点上，次要索引指向的是对主键的引用，当根据主键查询数据比较少时无需回行。</p><p>当使用聚簇索引的表中出现不定长大字段时，此时会直接影响使用主键索引查询的效率，因为主键索引与数据是共同分布在同一片叶子结点上的，当使用主键索引查询时就需要跨过多个页面（Pages）。</p><h3 id="索引覆盖" tabindex="-1"><a class="header-anchor" href="#索引覆盖" aria-hidden="true">#</a> 索引覆盖</h3><p>索引覆盖指的是：如果查询的列恰好是索引的一部分，那么该查询只需在索引中取数据，无需回行。</p><h3 id="联合索引" tabindex="-1"><a class="header-anchor" href="#联合索引" aria-hidden="true">#</a> 联合索引</h3><p>由于 MySQL 查询每次只能用到一个索引，所以在真实业务场景中更多的是加「联合索引」。联合索引设立及使用需要遵守「左前缀」原则。</p><p>特殊情况下可以设置双向索引。如文章、标签模型：需要用文章查标签，也需要通过标签查文章，索引设立：<code>(artical_id, tag_id)</code> 与 <code>(tag_id, artical_id)</code> 双向关联，充分利用索引覆盖。</p><h2 id="排序优化" tabindex="-1"><a class="header-anchor" href="#排序优化" aria-hidden="true">#</a> 排序优化</h2><p>排序条件尽量和查询条件保持一致，使用共同索引。由于索引本身是有序的，自然能提高排序的速度，同时也能够提高分组速度，因为分组需要先排序。</p><h2 id="sql-优化" tabindex="-1"><a class="header-anchor" href="#sql-优化" aria-hidden="true">#</a> SQL 优化</h2><p>SQL 优化大原则：不查 &gt; 少查 &gt; 高效查询</p><h3 id="复杂语句拆分" tabindex="-1"><a class="header-anchor" href="#复杂语句拆分" aria-hidden="true">#</a> 复杂语句拆分</h3><p>很多复杂的 SQL 都是可以拆分的。比如典型的连表查询，通常情况下，如果一个查询中出现超过连 3 张表的情况，大概率说明表结构设计不合理，其次可能是贪图“一条 SQL 完事”这种偷懒的做法。多表连查的劣势是查询效率会随着所有参与查询的表的数据量增长而变得越来越慢，可扩展性也会下降，当然如果你的表数据是可控的，连表查询说不定也是个好办法。但是切记 99% 的连表查询都可以通过「加冗余字段」的方式被拆分优化掉。</p><h3 id="in-型子查询陷阱" tabindex="-1"><a class="header-anchor" href="#in-型子查询陷阱" aria-hidden="true">#</a> in 型子查询陷阱</h3><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods <span class="token keyword">where</span> cate_id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> categories <span class="token keyword">where</span> parent_id<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>上面的 SQL 按照直觉来看，是先查询子句，取出所有 <code>parent_id=9</code> 的栏目 ID，然后再根据栏目 ID 拿商品数据。</p><p>但是在 MySQL 底层，这里的 in 被查询优化器优化为了 exists，相当于扫全 goods 表的数据，挨个跟 categories 的 <code>parent_id=9</code> 条件作比较。此时，goods 表中的数据越多，查询就越慢。</p><p>将 in 改为 inner join 可以优化此种情况，因为 inner join 会创建一个临时表，还可以用上索引：</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> goods<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> goods <span class="token keyword">inner</span> <span class="token keyword">join</span>
  <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> categories <span class="token keyword">where</span> parent_id<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">)</span> cates <span class="token keyword">on</span> goods<span class="token punctuation">.</span>cate_id<span class="token operator">=</span>cates<span class="token punctuation">.</span>id
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="from-型子查询慎用" tabindex="-1"><a class="header-anchor" href="#from-型子查询慎用" aria-hidden="true">#</a> from 型子查询慎用</h3><p>使用 from 型子查询，由内层查到的结果构成的临时表是没有索引的，所以内层返回的内容要尽量少，需要排序先在内层排好。</p><h3 id="count-排序优化" tabindex="-1"><a class="header-anchor" href="#count-排序优化" aria-hidden="true">#</a> count(*) 排序优化</h3><p>在 MyISAM 引擎中记录了表的行数，当使用 count 统计整张表的记录数时就很快，但是一旦有了 where 条件统计速度就取决于索引的速度了。</p><p>在 InnoDB 中，count 的速度取决于查询条件中的索引使用状况，同时也取决于经过 where 条件筛选后的数据行数。若使用了主键作为统计条件，就会受到表中大字段的影响。说到底 count 的优化就是使用区分度高的 where 条件尽量减少统计的记录数。</p><p>另外基于大范围统计，可以使用作差法实现优化的效果：</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> goods <span class="token keyword">where</span> id<span class="token operator">&gt;</span><span class="token number">100</span>   <span class="token comment">-- 很慢</span>

<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> goods                <span class="token comment">-- 很快</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> goods <span class="token keyword">where</span> id<span class="token operator">&lt;=</span><span class="token number">100</span>  <span class="token comment">-- 很快</span>
<span class="token comment">-- 两者相结合实现 id&gt;100 效果</span>
<span class="token keyword">select</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> goods<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> goods <span class="token keyword">where</span> id<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="limit-分页优化" tabindex="-1"><a class="header-anchor" href="#limit-分页优化" aria-hidden="true">#</a> limit 分页优化</h3><p>分页语句 <code>limit offset, N</code>，当 offset 越大时，查询越慢。</p><p>原因是如 <code>limit 10000, 20</code> 并不是直觉中的从第 <code>10000</code> 行开始拿 <code>20</code> 条数据，而是拿出 <code>10020</code> 条数据，然后把前 <code>10000</code> 条丢弃只留下最后 <code>20</code> 条返回。</p><h4 id="优化方法" tabindex="-1"><a class="header-anchor" href="#优化方法" aria-hidden="true">#</a> 优化方法：</h4><ol><li>（最优解）业务上限制分页数量，最多只能翻 100 页</li><li>不使用 offset，改为条件查询（有条件限制，如 ID 必须连续）<div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">20</span>
<span class="token comment">-- 改为</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods <span class="token keyword">where</span> id<span class="token operator">&gt;</span><span class="token number">1000000</span> <span class="token keyword">limit</span> <span class="token number">20</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li>采用 inner join，延迟关联（索引覆盖，减少回行）<div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> goods <span class="token keyword">inner</span> <span class="token keyword">join</span>
  <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> goods <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span> g <span class="token keyword">on</span> goods<span class="token punctuation">.</span>id<span class="token operator">=</span>g<span class="token punctuation">.</span>id
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">12/5/2021, 10:16:47 AM</span></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: sxyazi@gmail.com">sxyazi</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.39480b94.js" defer></script>
  </body>
</html>
